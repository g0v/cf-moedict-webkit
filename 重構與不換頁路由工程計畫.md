# 重構與不換頁路由工程計畫

## 階段 0：現況盤點與限制確認
- [x] 盤點 `page-rendering.ts` 與 `renderToString` 的 SSR 聲明生命週期，確認可在 Preact 端建立主佈局組件並於 SSR 時注入必要的 `<script>`。
- [x] 釐清現有 inline script（navbar dropdown、tooltip、starred、TTS、播放音檔等）對 DOM 結構與 CSS 選擇器的依賴程度，判斷抽離/轉換為元件內部事件或保留為注入腳本的可行性。
- [x] 確認 `Env` 來源與 R2 endpoint（`ASSET_BASE_URL`、`DICTIONARY_BASE_URL`、`DICTIONARY` KV）在瀏覽器端的可用性，評估需暴露的 API 端點與權限限制。

## 階段 1：元件與檔案結構重整
- [x] 建立 `components/Navbar/index.tsx`（或等同結構）並搬移 `NavbarComponent`，評估 props 需求（`currentLang`、事件 callback、共用狀態）。
- [x] 建立 `views` 子資料夾：`views/AboutView.tsx`、`views/DictionaryView.tsx`、`views/RadicalView.tsx`、`views/StarredView.tsx`，將現有 SSR 組件（`AboutPage`、`DictionaryPage`、`SearchResultsPage`、`NotFoundPage`、`StarredPage`/`StarredPageSSR`、`Radical` 相關）拆分/合併成新的展示元件。
- [x] 規劃 `layouts/MainLayout.tsx` 作為父層，包覆 `Navbar` 與中央內容，定義核心 props/state（目前選中的 route、lang、查詢字詞等）。
- [ ] 梳理共用工具與型別，將 `decorateRuby`、`rightAngle`、`lookupDictionaryEntry` 等共用函式以模組形式重用，避免迴圈依賴。

## 階段 2：路由狀態與事件集中管理
- [ ] 設計內部路由狀態（History API vs. Hash routing），評估與既有 hash 片段（`#=*`、`#@`）兼容方式。
- [ ] 在 `MainLayout` 中實作路由解析器：將 hash/path 拆解為 `{ view: 'dictionary' | 'about' | 'radical' | 'starred', lang, payload }`，提供給子元件使用。
- [ ] 將現有散落在 `generateHTMLWrapper` 內的 click/hash 攔截邏輯整理成集中式 handler，透過 Preact 狀態更新與 `history.pushState`/`replaceState` 控制。
- [ ] 定義「類似 Vue emit」的機制：透過 props 傳入 callback 或 Context，讓 `Navbar`、`DictionaryView`、`RadicalView` 等觸發路由切換時僅改變父層狀態。

## 階段 3：資料載入與重繪策略
- [ ] 決定字典資料的取得方式：在瀏覽器端呼叫現有 `/:text.json` API，或直接命中 R2 公開端點；評估 CORS 與憑證需求。
- [ ] 將 `lookupDictionaryEntry`、`performFuzzySearch`、`getDefinition` 等函式萃取成可於前端呼叫的 fetch helpers，注意與 Worker 端程式碼共用的可行性。
- [ ] 為 `DictionaryView` 實作資料狀態機制（載入中、成功、失敗），確保切換字詞時不會重新掛載 `Navbar`。
- [ ] 為 `RadicalView` 建立相同資料流程（載入部首列表 / 單部首內容），支援 hash/path 變化時的局部重繪。
- [ ] 釐清 `Starred` 與 `LRU` 相關 localStorage 操作，考慮改寫為 hook 或 effect，避免重複注入 DOM click handler。

## 階段 4：SSR 與 Hydration 策略
- [ ] 規劃 Worker 端輸出：`page-rendering.ts` 改為渲染 `MainLayout` 並注入初始路由狀態與資料（可透過 `window.__INITIAL_STATE__`）。
- [ ] 評估 Preact SSR + Hydration（`preact/compat` 或 `preact-render-to-string` 搭配 `hydrate`）的限制，確保前端路由狀態切換不破壞 SSR 結果。
- [ ] 重新檢視目前在 `<head>` 內的全域 script，拆分為：必須 SSR 前就存在的（如 polyfill）、可延後載入的（howler、bootstrap dropdown）。
- [ ] 設計 fallback：若前端路由啟動失敗，應保留既有的重新導向行為（即整頁 reload）。

## 階段 5：漸進導入與測試
- [ ] 規劃改造順序（先搬遷檔案與組件、再導入路由狀態、最後處理資料載入），確保每階段可回復。
- [ ] 撰寫單元測試／端對端測試計畫：涵蓋路由切換、localStorage 操作、Tooltip/Starred/TTS 功能。
- [ ] 建立手動驗收清單：桌機/手機、各語言切換、部首頁、收藏頁、字典頁的互動流程。
- [ ] 評估效能與可存取性影響（初次載入體積、hydration 時間、鍵盤操作）。

## 階段 6：文件與移交
- [ ] 更新開發文件（README 或新章節）說明新的元件架構、路由流程、資料取得方式。
- [ ] 標註需要後續討論/驗證的開放議題（例如：Tooltip 是否改寫成 Preact 元件、是否採用第三方路由庫如 `preact-router`）。


---

**計畫版本**: v1.0 (TODO List 格式)
**創建日期**: 2025-10-29
**最後更新**: 2025-10-29
